// server/routes/pentest-requests.js
const express = require('express');
const router = express.Router();
const { pool } = require('../db');

/**
 * Get all pentest requests
 * GET /pentest-requests
 * curl http://localhost:3000/pentest-requests
 */
router.get('/', async (req, res) => {
  try {
    const [rows] = await pool.query(`
      SELECT pr.*, c.company_name, u.name as requestor_name
      FROM pentest_requests pr
      JOIN clients c ON pr.client_id = c.client_id
      JOIN users u ON pr.user_id = u.user_id
    `);
    res.json(rows);
  } catch (error) {
    console.error('Error fetching pentest requests:', error);
    res.status(500).json({ error: 'Failed to retrieve pentest requests' });
  }
});

/**
 * Get pentest request by ID
 * GET /pentest-requests/:id
 * curl http://localhost:3000/pentest-requests/1
 */
router.get('/:id', async (req, res) => {
  try {
    const [rows] = await pool.query(
      'SELECT * FROM pentest_requests WHERE pentest_request_id = ?', 
      [req.params.id]
    );
    
    if (rows.length === 0) {
      return res.status(404).json({ error: 'Pentest request not found' });
    }
    
    res.json(rows[0]);
  } catch (error) {
    console.error('Error fetching pentest request:', error);
    res.status(500).json({ error: 'Failed to retrieve pentest request' });
  }
});

/**
 * Get pentest requests by client ID
 * GET /pentest-requests/client/:clientId
 * curl http://localhost:3000/pentest-requests/client/1
 */
router.get('/client/:clientId', async (req, res) => {
  try {
    const [rows] = await pool.query(`
      SELECT pr.*, c.company_name, u.name as requestor_name
      FROM pentest_requests pr
      JOIN clients c ON pr.client_id = c.client_id
      JOIN users u ON pr.user_id = u.user_id
      WHERE pr.client_id = ?
    `, [req.params.clientId]);
    
    res.json(rows);
  } catch (error) {
    console.error('Error fetching client pentest requests:', error);
    res.status(500).json({ error: 'Failed to retrieve client pentest requests' });
  }
});


/**
 * Create new pentest request
 * POST /pentest-requests
 * curl -X POST http://localhost:3000/pentest-requests \
  -H "Content-Type: application/json" \
  -d "{\"client_id\":1,\"user_id\":1,\"description\":{\"project_name\":\"Web App Security Test\",\"scope\":\"Full application assessment\",\"timeline\":\"4 weeks\"}}"
 */
router.post('/', async (req, res) => {
  const { client_id, user_id, description, request_status = 'NEW' } = req.body;
  
  // Basic input validation
  if (!client_id || !user_id ||  !description) {
    return res.status(400).json({ error: 'Missing required fields' });
  }
  
  try {
    // Check if client already has a pentest request
    const [existingRequest] = await pool.query(
      'SELECT pentest_request_id FROM pentest_requests WHERE client_id = ?', 
      [client_id]
    );

    if (existingRequest.length > 0) {
      return res.status(409).json({ 
        error: 'A pentest request already exists for this client',
        existing_request_id: existingRequest[0].pentest_request_id
      });
    }

    // Verify client and user exist
    const [[client], [user]] = await Promise.all([
      pool.query('SELECT client_id FROM clients WHERE client_id = ?', [client_id]),
      pool.query('SELECT user_id FROM users WHERE user_id = ?', [user_id])
    ]);

    if (!client || !user) {
      return res.status(404).json({ error: 'Invalid client or user' });
    }
    
    // Insert pentest request
    const [result] = await pool.query(
      'INSERT INTO pentest_requests (client_id, user_id, description, request_status) VALUES (?, ?, ?, ?)',
      [client_id, user_id, JSON.stringify(description), request_status]
    );
    
    // Log activity
    await pool.query(
      'INSERT INTO activity_logs (user_id, pentest_request_id, action_type) VALUES (?, ?, ?)',
      [user_id, result.insertId, 'CREATE_REQUEST']
    );
    
    // Fetch and return the created request
    const [newRequest] = await pool.query(`
      SELECT 
        pr.pentest_request_id as request_id, 
        pr.*, 
        c.company_name, 
        u.name as requestor_name
      FROM pentest_requests pr
      JOIN clients c ON pr.client_id = c.client_id
      JOIN users u ON pr.user_id = u.user_id
      WHERE pr.pentest_request_id = ?
    `, [result.insertId]);
    
    res.status(201).json(newRequest[0]);
  } catch (error) {
    console.error('Pentest request creation error:', error);
    res.status(500).json({ error: 'Request creation failed' });
  }
});
/**
 * Update pentest request status
 * PUT /pentest-requests/:id/status
 * curl -X PUT http://localhost:3000/pentest-requests/1/status \
  -H "Content-Type: application/json" \
  -d "{\"request_status\":\"SOW_DRAFTED\"}"
 */
router.put('/:id/status', async (req, res) => {
  const { request_status } = req.body;
  
  // Validate status
  if (!request_status) {
    return res.status(400).json({ error: 'Request status is required' });
  }
  
  // Validate status enum
  const validStatuses = ['NEW', 'SOW_DRAFTED', 'SOW_APPROVED', 'COMPLETED'];
  if (!validStatuses.includes(request_status)) {
    return res.status(400).json({ 
      error: 'Invalid status. Must be one of: NEW, SOW_DRAFTED, SOW_APPROVED, COMPLETED' 
    });
  }
  
  try {
    // Check if request exists and get user_id for logging
    const [requestRows] = await pool.query(
      'SELECT user_id FROM pentest_requests WHERE pentest_request_id = ?', 
      [req.params.id]
    );
    
    if (requestRows.length === 0) {
      return res.status(404).json({ error: 'Pentest request not found' });
    }
    
    const user_id = requestRows[0].user_id;
    
    // Update request status
    const [result] = await pool.query(
      'UPDATE pentest_requests SET request_status = ? WHERE pentest_request_id = ?',
      [request_status, req.params.id]
    );
    
    // Log activity
    await pool.query(
      'INSERT INTO activity_logs (user_id, pentest_request_id, action_type) VALUES (?, ?, ?)',
      [user_id, req.params.id, 'UPDATE_REQUEST']
    );
    
    // Get the updated request with joined data
    const [updatedRequest] = await pool.query(`
      SELECT 
        pr.pentest_request_id as request_id,
        pr.*, 
        c.company_name, 
        u.name as requestor_name
      FROM pentest_requests pr
      JOIN clients c ON pr.client_id = c.client_id
      JOIN users u ON pr.user_id = u.user_id
      WHERE pr.pentest_request_id = ?
    `, [req.params.id]);
    
    res.json(updatedRequest[0]);
  } catch (error) {
    console.error('Error updating pentest request status:', error);
    res.status(500).json({ error: 'Failed to update pentest request status', details: error.message });
  }
});

/**
 * Update pentest request details
 * PUT /pentest-requests/:id
 * curl -X PUT http://localhost:3000/pentest-requests/1 \
  -H "Content-Type: application/json" \
  -d "{\"description\":{\"project_name\":\"Web and Mobile App Security Test\",\"scope\":\"Extended application assessment\",\"timeline\":\"6 weeks\"}}"
 */
router.put('/:id', async (req, res) => {
  const { description, client_id, user_id, request_status } = req.body;
  
  // Validate that at least one field is being updated
  if (!description && !client_id && !user_id && !request_status) {
    return res.status(400).json({ error: 'At least one field must be updated' });
  }
  
  // Validate status enum if provided
  if (request_status) {
    const validStatuses = ['NEW', 'SOW_DRAFTED', 'SOW_APPROVED', 'COMPLETED'];
    if (!validStatuses.includes(request_status)) {
      return res.status(400).json({ 
        error: 'Invalid status. Must be one of: NEW, SOW_DRAFTED, SOW_APPROVED, COMPLETED' 
      });
    }
  }
  
  try {
    // Check if request exists and get current data
    const [requestRows] = await pool.query(
      'SELECT * FROM pentest_requests WHERE pentest_request_id = ?', 
      [req.params.id]
    );
    
    if (requestRows.length === 0) {
      return res.status(404).json({ error: 'Pentest request not found' });
    }
    
    const existingRequest = requestRows[0];
    
    // Verify client exists if updating client_id
    if (client_id) {
      const [clientRows] = await pool.query('SELECT client_id FROM clients WHERE client_id = ?', [client_id]);
      if (clientRows.length === 0) {
        return res.status(404).json({ error: 'Client not found' });
      }
    }
    
    // Verify user exists if updating user_id
    if (user_id) {
      const [userRows] = await pool.query('SELECT user_id FROM users WHERE user_id = ?', [user_id]);
      if (userRows.length === 0) {
        return res.status(404).json({ error: 'User not found' });
      }
    }
    
    // Build update query dynamically based on provided fields
    const updates = [];
    const values = [];
    
    if (description) {
      updates.push('description = ?');
      values.push(JSON.stringify(description));
    }
    
    if (client_id) {
      updates.push('client_id = ?');
      values.push(client_id);
    }
    
    if (user_id) {
      updates.push('user_id = ?');
      values.push(user_id);
    }
    
    if (request_status) {
      updates.push('request_status = ?');
      values.push(request_status);
    }
    
    // Add pentest_request_id as the last parameter
    values.push(req.params.id);
    
    // Update request
    const [result] = await pool.query(
      `UPDATE pentest_requests SET ${updates.join(', ')} WHERE pentest_request_id = ?`,
      values
    );
    
    // Log activity
    await pool.query(
      'INSERT INTO activity_logs (user_id, pentest_request_id, action_type) VALUES (?, ?, ?)',
      [existingRequest.user_id, req.params.id, 'UPDATE_REQUEST']
    );
    
    // Get updated request with joined data
    const [updatedRows] = await pool.query(`
      SELECT 
        pr.pentest_request_id as request_id,
        pr.*, 
        c.company_name, 
        u.name as requestor_name
      FROM pentest_requests pr
      JOIN clients c ON pr.client_id = c.client_id
      JOIN users u ON pr.user_id = u.user_id
      WHERE pr.pentest_request_id = ?
    `, [req.params.id]);
    
    res.json(updatedRows[0]);
  } catch (error) {
    console.error('Error updating pentest request:', error);
    res.status(500).json({ error: 'Failed to update pentest request', details: error.message });
  }
});


/**
 * Delete pentest request
 * DELETE /pentest-requests/:id
 * curl -X DELETE http://localhost:3000/pentest-requests/1
 */
router.delete('/:id', async (req, res) => {
  try {
    // Check if request exists
    const [requestRows] = await pool.query(
      'SELECT * FROM pentest_requests WHERE pentest_request_id = ?', 
      [req.params.id]
    );
    
    if (requestRows.length === 0) {
      return res.status(404).json({ error: 'Pentest request not found' });
    }
    
    // Delete associated chatbot logs first
    await pool.query(
      'DELETE FROM chatbot_logs WHERE pentest_request_id = ?', 
      [req.params.id]
    );
    
    // Delete associated activity logs
    await pool.query(
      'DELETE FROM activity_logs WHERE pentest_request_id = ?', 
      [req.params.id]
    );
    
    // Delete associated reports
    await pool.query(
      'DELETE FROM reports WHERE pentest_request_id = ?', 
      [req.params.id]
    );
    
    // Delete request
    const [result] = await pool.query(
      'DELETE FROM pentest_requests WHERE pentest_request_id = ?', 
      [req.params.id]
    );
    
    res.status(204).send();
  } catch (error) {
    console.error('Error deleting pentest request:', error);
    
    // Check if error is due to foreign key constraint
    if (error.code === 'ER_ROW_IS_REFERENCED') {
      return res.status(400).json({ 
        error: 'Cannot delete request. Check associated records.' 
      });
    }
    
    res.status(500).json({ 
      error: 'Failed to delete pentest request', 
      details: error.message 
    });
  }
});

module.exports = router;